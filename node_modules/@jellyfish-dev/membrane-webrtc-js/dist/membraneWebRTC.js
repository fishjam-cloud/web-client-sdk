"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MembraneWebRTC = void 0;
const mediaEvent_1 = require("./mediaEvent");
const uuid_1 = require("uuid");
const events_1 = require("events");
const const_1 = require("./const");
const vadStatuses = ["speech", "silence"];
class TrackContextImpl extends events_1.EventEmitter {
    constructor(peer, trackId, metadata) {
        super();
        this.track = null;
        this.stream = null;
        this.maxBandwidth = 0;
        this.vadStatus = "silence";
        this.negotiationStatus = "awaiting";
        // Indicates that metadata were changed when in "offered" negotiationStatus
        // and `updateTrackMetadata` Media Event should be sent after the transition to "done"
        this.pendingMetadataUpdate = false;
        this.peer = peer;
        this.trackId = trackId;
        this.metadata = metadata;
    }
}
/**
 * Main class that is responsible for connecting to the RTC Engine, sending and receiving media.
 */
class MembraneWebRTC extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.localTracksWithStreams = [];
        this.trackIdToTrack = new Map();
        this.idToPeer = new Map();
        this.localPeer = {
            id: "",
            metadata: {},
            trackIdToMetadata: new Map(),
        };
        this.localTrackIdToTrack = new Map();
        this.midToTrackId = new Map();
        this.disabledTrackEncodings = new Map();
        this.rtcConfig = {
            iceServers: [],
            iceTransportPolicy: "relay",
        };
        /**
         * Tries to join to the RTC Engine. If user is accepted then {@link Callbacks.onJoinSuccess}
         * will be called. In other case {@link Callbacks.onJoinError} is invoked.
         *
         * @param peerMetadata - Any information that other peers will receive in {@link Callbacks.onPeerJoined}
         * after accepting this peer
         *
         * @example
         * ```ts
         * let webrtc = new MembraneWebRTC(...)
         * webrtc.join({displayName: "Bob"})
         * ```
         */
        this.join = (peerMetadata) => {
            var _a, _b;
            try {
                this.localPeer.metadata = peerMetadata;
                let mediaEvent = (0, mediaEvent_1.generateMediaEvent)("join", {
                    metadata: peerMetadata,
                });
                this.sendMediaEvent(mediaEvent);
            }
            catch (e) {
                (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onConnectionError) === null || _b === void 0 ? void 0 : _b.call(_a, e);
                this.emit("onConnectionError", e);
                this.leave();
            }
        };
        /**
         * Feeds media event received from RTC Engine to {@link MembraneWebRTC}.
         * This function should be called whenever some media event from RTC Engine
         * was received and can result in {@link MembraneWebRTC} generating some other
         * media events.
         *
         * @param mediaEvent - String data received over custom signalling layer.
         *
         * @example
         * This example assumes pheonix channels as signalling layer.
         * As phoenix channels require objects, RTC Engine encapsulates binary data into
         * map with one field that is converted to object with one field on the TS side.
         * ```ts
         * webrtcChannel.on("mediaEvent", (event) => webrtc.receiveMediaEvent(event.data));
         * ```
         */
        this.receiveMediaEvent = (mediaEvent) => {
            var _a, _b, _c, _d;
            const deserializedMediaEvent = (0, mediaEvent_1.deserializeMediaEvent)(mediaEvent);
            switch (deserializedMediaEvent.type) {
                case "peerAccepted":
                    this.localPeer.id = deserializedMediaEvent.data.id;
                    (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onJoinSuccess) === null || _b === void 0 ? void 0 : _b.call(_a, deserializedMediaEvent.data.id, deserializedMediaEvent.data.peersInRoom);
                    this.emit("onJoinSuccess", deserializedMediaEvent.data.id, deserializedMediaEvent.data.peersInRoom);
                    let peers = deserializedMediaEvent.data.peersInRoom;
                    peers.forEach((peer) => {
                        this.addPeer(peer);
                    });
                    peers.forEach((peer) => {
                        Array.from(peer.trackIdToMetadata.entries()).forEach(([trackId, metadata]) => {
                            var _a, _b;
                            const ctx = new TrackContextImpl(peer, trackId, metadata);
                            this.trackIdToTrack.set(trackId, ctx);
                            (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onTrackAdded) === null || _b === void 0 ? void 0 : _b.call(_a, ctx);
                            this.emit("onTrackAdded", ctx);
                        });
                    });
                    break;
                case "peerDenied":
                    (_d = (_c = this.callbacks) === null || _c === void 0 ? void 0 : _c.onJoinError) === null || _d === void 0 ? void 0 : _d.call(_c, deserializedMediaEvent.data);
                    this.emit("onJoinError", deserializedMediaEvent.data);
                    break;
                default:
                    if (this.localPeer.id != null)
                        this.handleMediaEvent(deserializedMediaEvent);
            }
        };
        this.handleMediaEvent = (deserializedMediaEvent) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
            let peer;
            let data;
            switch (deserializedMediaEvent.type) {
                case "offerData":
                    const turnServers = deserializedMediaEvent.data.integratedTurnServers;
                    this.setTurns(turnServers);
                    const offerData = new Map(Object.entries(deserializedMediaEvent.data.tracksTypes));
                    this.onOfferData(offerData);
                    break;
                case "tracksAdded":
                    data = deserializedMediaEvent.data;
                    if (this.getPeerId() === data.peerId)
                        return;
                    data.trackIdToMetadata = new Map(Object.entries(data.trackIdToMetadata));
                    peer = this.idToPeer.get(data.peerId);
                    const oldTrackIdToMetadata = peer.trackIdToMetadata;
                    peer.trackIdToMetadata = new Map([
                        ...peer.trackIdToMetadata,
                        ...data.trackIdToMetadata,
                    ]);
                    this.idToPeer.set(peer.id, peer);
                    Array.from(peer.trackIdToMetadata.entries()).forEach(([trackId, metadata]) => {
                        var _a, _b;
                        if (!oldTrackIdToMetadata.has(trackId)) {
                            const ctx = new TrackContextImpl(peer, trackId, metadata);
                            this.trackIdToTrack.set(trackId, ctx);
                            (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onTrackAdded) === null || _b === void 0 ? void 0 : _b.call(_a, ctx);
                            this.emit("onTrackAdded", ctx);
                        }
                    });
                    break;
                case "tracksRemoved":
                    data = deserializedMediaEvent.data;
                    const peerId = data.peerId;
                    if (this.getPeerId() === data.peerId)
                        return;
                    const trackIds = data.trackIds;
                    trackIds.forEach((trackId) => {
                        var _a, _b;
                        const trackContext = this.trackIdToTrack.get(trackId);
                        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onTrackRemoved) === null || _b === void 0 ? void 0 : _b.call(_a, trackContext);
                        this.emit("onTrackRemoved", trackContext);
                        this.eraseTrack(trackId, peerId);
                    });
                    break;
                case "sdpAnswer":
                    this.midToTrackId = new Map(Object.entries(deserializedMediaEvent.data.midToTrackId));
                    for (let trackId of Object.values(deserializedMediaEvent.data.midToTrackId)) {
                        const track = this.localTrackIdToTrack.get(trackId);
                        // if is local track
                        if (track) {
                            track.negotiationStatus = "done";
                            if (track.pendingMetadataUpdate) {
                                const mediaEvent = (0, mediaEvent_1.generateMediaEvent)("updateTrackMetadata", {
                                    trackId,
                                    trackMetadata: track.metadata,
                                });
                                this.sendMediaEvent(mediaEvent);
                            }
                            track.pendingMetadataUpdate = false;
                        }
                    }
                    this.onAnswer(deserializedMediaEvent.data);
                    break;
                case "candidate":
                    this.onRemoteCandidate(deserializedMediaEvent.data);
                    break;
                case "peerJoined":
                    peer = deserializedMediaEvent.data.peer;
                    if (peer.id === this.getPeerId())
                        return;
                    this.addPeer(peer);
                    (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onPeerJoined) === null || _b === void 0 ? void 0 : _b.call(_a, peer);
                    this.emit("onPeerJoined", peer);
                    break;
                case "peerLeft":
                    peer = this.idToPeer.get(deserializedMediaEvent.data.peerId);
                    if (peer === undefined)
                        return;
                    Array.from(peer.trackIdToMetadata.keys()).forEach((trackId) => {
                        var _a, _b;
                        (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onTrackRemoved) === null || _b === void 0 ? void 0 : _b.call(_a, this.trackIdToTrack.get(trackId));
                        this.emit("onTrackRemoved", this.trackIdToTrack.get(trackId));
                    });
                    this.erasePeer(peer);
                    (_d = (_c = this.callbacks) === null || _c === void 0 ? void 0 : _c.onPeerLeft) === null || _d === void 0 ? void 0 : _d.call(_c, peer);
                    this.emit("onPeerLeft", peer);
                    break;
                case "peerUpdated":
                    if (this.getPeerId() === deserializedMediaEvent.data.peerId)
                        return;
                    peer = this.idToPeer.get(deserializedMediaEvent.data.peerId);
                    peer.metadata = deserializedMediaEvent.data.metadata;
                    this.addPeer(peer);
                    (_f = (_e = this.callbacks) === null || _e === void 0 ? void 0 : _e.onPeerUpdated) === null || _f === void 0 ? void 0 : _f.call(_e, peer);
                    this.emit("onPeerUpdated", peer);
                    break;
                case "peerRemoved":
                    if (this.getPeerId() !== deserializedMediaEvent.data.peerId) {
                        console.error("Received onRemoved media event, but it does not refer to the local peer");
                        return;
                    }
                    (_h = (_g = this.callbacks) === null || _g === void 0 ? void 0 : _g.onRemoved) === null || _h === void 0 ? void 0 : _h.call(_g, deserializedMediaEvent.data.reason);
                    this.emit("onRemoved", deserializedMediaEvent.data.reason);
                    break;
                case "trackUpdated": {
                    if (this.getPeerId() === deserializedMediaEvent.data.peerId)
                        return;
                    peer = this.idToPeer.get(deserializedMediaEvent.data.peerId);
                    if (peer == null)
                        throw `Peer with id: ${deserializedMediaEvent.data.peerId} doesn't exist`;
                    const trackId = deserializedMediaEvent.data.trackId;
                    const trackMetadata = deserializedMediaEvent.data.metadata;
                    peer.trackIdToMetadata.set(trackId, trackMetadata);
                    const trackContext = this.trackIdToTrack.get(trackId);
                    trackContext.metadata = trackMetadata;
                    (_k = (_j = this.callbacks) === null || _j === void 0 ? void 0 : _j.onTrackUpdated) === null || _k === void 0 ? void 0 : _k.call(_j, trackContext);
                    this.emit("onTrackUpdated", trackContext);
                    break;
                }
                case "tracksPriority":
                    const enabledTracks = deserializedMediaEvent.data.tracks.map((trackId) => this.trackIdToTrack.get(trackId));
                    const disabledTracks = Array.from(this.trackIdToTrack.values()).filter((track) => !enabledTracks.includes(track));
                    (_m = (_l = this.callbacks) === null || _l === void 0 ? void 0 : _l.onTracksPriorityChanged) === null || _m === void 0 ? void 0 : _m.call(_l, enabledTracks, disabledTracks);
                    this.emit("onTracksPriorityChanged", enabledTracks, disabledTracks);
                case "encodingSwitched":
                    const trackId = deserializedMediaEvent.data.trackId;
                    const trackContext = this.trackIdToTrack.get(trackId);
                    trackContext.encoding = deserializedMediaEvent.data.encoding;
                    trackContext.encodingReason = deserializedMediaEvent.data.reason;
                    (_o = trackContext.onEncodingChanged) === null || _o === void 0 ? void 0 : _o.call(trackContext);
                    trackContext.emit("onEncodingChanged", trackContext);
                    // will be removed in the future
                    (_q = (_p = this.callbacks) === null || _p === void 0 ? void 0 : _p.onTrackEncodingChanged) === null || _q === void 0 ? void 0 : _q.call(_p, trackContext.peer.id, trackId, trackContext.encoding);
                    this.emit("onTrackEncodingChanged", trackContext.peer.id, trackId, trackContext.encoding);
                    break;
                case "custom":
                    this.handleMediaEvent(deserializedMediaEvent.data);
                    break;
                case "error":
                    (_s = (_r = this.callbacks) === null || _r === void 0 ? void 0 : _r.onConnectionError) === null || _s === void 0 ? void 0 : _s.call(_r, deserializedMediaEvent.data.message);
                    this.emit("onConnectionError", deserializedMediaEvent.data.message);
                    this.leave();
                    break;
                case "vadNotification": {
                    const trackId = deserializedMediaEvent.data.trackId;
                    const ctx = this.trackIdToTrack.get(trackId);
                    const vadStatus = deserializedMediaEvent.data.status;
                    if (vadStatuses.includes(vadStatus)) {
                        ctx.vadStatus = vadStatus;
                        (_t = ctx.onVoiceActivityChanged) === null || _t === void 0 ? void 0 : _t.call(ctx);
                        ctx.emit("onVoiceActivityChanged", ctx);
                    }
                    else {
                        console.warn("Received unknown vad status: ", vadStatus);
                    }
                    break;
                }
                case "bandwidthEstimation": {
                    const estimation = deserializedMediaEvent.data.estimation;
                    (_v = (_u = this.callbacks) === null || _u === void 0 ? void 0 : _u.onBandwidthEstimationChanged) === null || _v === void 0 ? void 0 : _v.call(_u, estimation);
                    this.emit("onBandwidthEstimationChanged", estimation);
                    break;
                }
                default:
                    console.warn("Received unknown media event: ", deserializedMediaEvent.type);
                    break;
            }
        };
        this.addTrackToConnection = (trackContext) => {
            let transceiverConfig = this.createTransceiverConfig(trackContext);
            const track = trackContext.track;
            this.connection.addTransceiver(track, transceiverConfig);
        };
        /**
         * Updates the metadata for the current peer.
         * @param peerMetadata - Data about this peer that other peers will receive upon joining.
         *
         * If the metadata is different from what is already tracked in the room, the optional
         * callback `onPeerUpdated` will be triggered for other peers in the room.
         */
        this.updatePeerMetadata = (peerMetadata) => {
            let mediaEvent = (0, mediaEvent_1.generateMediaEvent)("updatePeerMetadata", {
                metadata: peerMetadata,
            });
            this.sendMediaEvent(mediaEvent);
        };
        /**
         * Updates the metadata for a specific track.
         * @param trackId - trackId (generated in addTrack) of audio or video track.
         * @param trackMetadata - Data about this track that other peers will receive upon joining.
         *
         * If the metadata is different from what is already tracked in the room, the optional
         * callback `onTrackUpdated` will be triggered for other peers in the room.
         */
        this.updateTrackMetadata = (trackId, trackMetadata) => {
            const trackContext = this.localTrackIdToTrack.get(trackId);
            trackContext.metadata = trackMetadata;
            this.localTrackIdToTrack.set(trackId, trackContext);
            this.localPeer.trackIdToMetadata.set(trackId, trackMetadata);
            const mediaEvent = (0, mediaEvent_1.generateMediaEvent)("updateTrackMetadata", {
                trackId,
                trackMetadata,
            });
            switch (trackContext.negotiationStatus) {
                case "done":
                    this.sendMediaEvent(mediaEvent);
                    break;
                case "offered":
                    trackContext.pendingMetadataUpdate = true;
                    break;
                case "awaiting":
                    // We don't need to do anything
                    break;
            }
        };
        this.getMidToTrackId = () => {
            const localTrackMidToTrackId = {};
            if (!this.connection)
                return null;
            this.connection.getTransceivers().forEach((transceiver) => {
                var _a;
                const localTrackId = (_a = transceiver.sender.track) === null || _a === void 0 ? void 0 : _a.id;
                const mid = transceiver.mid;
                if (localTrackId && mid) {
                    const trackContext = Array.from(this.localTrackIdToTrack.values()).find((trackContext) => trackContext.track.id === localTrackId);
                    localTrackMidToTrackId[mid] = trackContext.trackId;
                }
            });
            return localTrackMidToTrackId;
        };
        /**
         * Leaves the room. This function should be called when user leaves the room
         * in a clean way e.g. by clicking a dedicated, custom button `disconnect`.
         * As a result there will be generated one more media event that should be
         * sent to the RTC Engine. Thanks to it each other peer will be notified
         * that peer left in {@link Callbacks.onPeerLeft},
         */
        this.leave = () => {
            let mediaEvent = (0, mediaEvent_1.generateMediaEvent)("leave");
            this.sendMediaEvent(mediaEvent);
            this.cleanUp();
        };
        /**
         * Cleans up {@link MembraneWebRTC} instance.
         */
        this.cleanUp = () => {
            if (this.connection) {
                this.connection.onicecandidate = null;
                this.connection.ontrack = null;
                this.connection.onconnectionstatechange = null;
                this.connection.onicecandidateerror = null;
                this.connection.oniceconnectionstatechange = null;
            }
            this.localTracksWithStreams.forEach(({ track }) => track.stop());
            this.localTracksWithStreams = [];
            this.connection = undefined;
        };
        this.sendMediaEvent = (mediaEvent) => {
            var _a;
            const serializedMediaEvent = (0, mediaEvent_1.serializeMediaEvent)(mediaEvent);
            (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onSendMediaEvent(serializedMediaEvent);
            this.emit("onSendMediaEvent", serializedMediaEvent);
        };
        this.onAnswer = async (answer) => {
            this.connection.ontrack = this.onTrack();
            try {
                await this.connection.setRemoteDescription(answer);
                this.disabledTrackEncodings.forEach((encodings, trackId) => {
                    encodings.forEach((encoding) => this.disableTrackEncoding(trackId, encoding));
                });
            }
            catch (err) {
                console.log(err);
            }
        };
        this.addTransceiversIfNeeded = (serverTracks) => {
            var _a;
            const recvTransceivers = this.connection.getTransceivers().filter((elem) => elem.direction === "recvonly");
            let toAdd = [];
            const getNeededTransceiversTypes = (type) => {
                let typeNumber = serverTracks.get(type);
                typeNumber = typeNumber !== undefined ? typeNumber : 0;
                const typeTransceiversNumber = recvTransceivers.filter((elem) => elem.receiver.track.kind === type).length;
                return Array(typeNumber - typeTransceiversNumber).fill(type);
            };
            const audio = getNeededTransceiversTypes("audio");
            const video = getNeededTransceiversTypes("video");
            toAdd = toAdd.concat(audio);
            toAdd = toAdd.concat(video);
            for (let kind of toAdd)
                (_a = this.connection) === null || _a === void 0 ? void 0 : _a.addTransceiver(kind, { direction: "recvonly" });
        };
        this.getTrackIdToMetadata = () => {
            const trackIdToMetadata = {};
            Array.from(this.localPeer.trackIdToMetadata.entries()).forEach(([trackId, metadata]) => {
                trackIdToMetadata[trackId] = metadata;
            });
            return trackIdToMetadata;
        };
        this.getTrackBitrates = (trackId) => {
            const trackContext = this.localTrackIdToTrack.get(trackId);
            if (!trackContext)
                throw "Track with id ${trackId} not present in 'localTrackIdToTrack'";
            const kind = trackContext.track.kind;
            const sender = this.findSender(trackContext.track.id);
            const encodings = sender.getParameters().encodings;
            if (encodings.length == 1 && !encodings[0].rid)
                return encodings[0].maxBitrate || const_1.defaultBitrates[kind];
            else if (kind == "audio")
                throw "Audio track cannot have multiple encodings";
            let bitrates = {};
            encodings
                .filter((encoding) => encoding.rid)
                .forEach((encoding) => {
                const rid = encoding.rid;
                bitrates[rid] = encoding.maxBitrate || const_1.defaultSimulcastBitrates[rid];
            });
            return bitrates;
        };
        this.getTrackIdToTrackBitrates = () => {
            const trackIdToTrackBitrates = {};
            Array.from(this.localPeer.trackIdToMetadata.entries()).forEach(([trackId, _metadata]) => {
                trackIdToTrackBitrates[trackId] = this.getTrackBitrates(trackId);
            });
            return trackIdToTrackBitrates;
        };
        this.checkIfTrackBelongToPeer = (trackId, peer) => Array.from(peer.trackIdToMetadata.keys()).some((track) => trackId.startsWith(track));
        this.onOfferData = async (offerData) => {
            if (!this.connection) {
                this.connection = new RTCPeerConnection(this.rtcConfig);
                this.connection.onicecandidate = this.onLocalCandidate();
                this.connection.onicecandidateerror = this.onIceCandidateError;
                this.connection.onconnectionstatechange = this.onConnectionStateChange;
                this.connection.oniceconnectionstatechange =
                    this.onIceConnectionStateChange;
                Array.from(this.localTrackIdToTrack.values()).forEach((trackContext) => this.addTrackToConnection(trackContext));
                this.connection
                    .getTransceivers()
                    .forEach((transceiver) => (transceiver.direction = "sendonly"));
            }
            else {
                await this.connection.restartIce();
            }
            this.addTransceiversIfNeeded(offerData);
            await this.createAndSendOffer();
        };
        this.onRemoteCandidate = (candidate) => {
            try {
                const iceCandidate = new RTCIceCandidate(candidate);
                if (!this.connection) {
                    throw new Error("Received new remote candidate but RTCConnection is undefined");
                }
                this.connection.addIceCandidate(iceCandidate);
            }
            catch (error) {
                console.error(error);
            }
        };
        this.onLocalCandidate = () => {
            return (event) => {
                if (event.candidate) {
                    let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
                        type: "candidate",
                        data: {
                            candidate: event.candidate.candidate,
                            sdpMLineIndex: event.candidate.sdpMLineIndex,
                        },
                    });
                    this.sendMediaEvent(mediaEvent);
                }
            };
        };
        this.onIceCandidateError = (event) => {
            console.warn(event);
        };
        this.onConnectionStateChange = (event) => {
            var _a, _b, _c;
            if (((_a = this.connection) === null || _a === void 0 ? void 0 : _a.connectionState) === "failed") {
                const message = "Connection failed";
                (_c = (_b = this.callbacks) === null || _b === void 0 ? void 0 : _b.onConnectionError) === null || _c === void 0 ? void 0 : _c.call(_b, message);
                this.emit("onConnectionError", message);
            }
        };
        this.onIceConnectionStateChange = (event) => {
            var _a, _b, _c;
            const errorMessages = "Ice connection failed";
            switch ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.iceConnectionState) {
                case "disconnected":
                    console.warn("ICE connection: disconnected");
                    break;
                case "failed":
                    (_c = (_b = this.callbacks) === null || _b === void 0 ? void 0 : _b.onConnectionError) === null || _c === void 0 ? void 0 : _c.call(_b, errorMessages);
                    this.emit("onConnectionError", errorMessages);
                    break;
            }
        };
        this.onTrack = () => {
            return (event) => {
                var _a, _b;
                const [stream] = event.streams;
                const mid = event.transceiver.mid;
                const trackId = this.midToTrackId.get(mid);
                if (this.checkIfTrackBelongToPeer(trackId, this.localPeer))
                    return;
                const trackContext = this.trackIdToTrack.get(trackId);
                trackContext.stream = stream;
                trackContext.track = event.track;
                (_b = (_a = this.callbacks) === null || _a === void 0 ? void 0 : _a.onTrackReady) === null || _b === void 0 ? void 0 : _b.call(_a, trackContext);
                this.emit("onTrackReady", trackContext);
            };
        };
        this.setTurns = (turnServers) => {
            turnServers.forEach((turnServer) => {
                var transport, uri;
                if (turnServer.transport == "tls") {
                    transport = "tcp";
                    uri = "turns";
                }
                else {
                    transport = turnServer.transport;
                    uri = "turn";
                }
                const rtcIceServer = {
                    credential: turnServer.password,
                    urls: uri.concat(":", turnServer.serverAddr, ":", turnServer.serverPort, "?transport=", transport),
                    username: turnServer.username,
                };
                this.rtcConfig.iceServers.push(rtcIceServer);
            });
        };
        this.addPeer = (peer) => {
            // #TODO remove this line after fixing deserialization
            if (peer.hasOwnProperty("trackIdToMetadata"))
                peer.trackIdToMetadata = new Map(Object.entries(peer.trackIdToMetadata));
            else
                peer.trackIdToMetadata = new Map();
            this.idToPeer.set(peer.id, peer);
        };
        this.erasePeer = (peer) => {
            const tracksId = Array.from(peer.trackIdToMetadata.keys());
            tracksId.forEach((trackId) => this.trackIdToTrack.delete(trackId));
            Array.from(this.midToTrackId.entries()).forEach(([mid, trackId]) => {
                if (tracksId.includes(trackId))
                    this.midToTrackId.delete(mid);
            });
            this.idToPeer.delete(peer.id);
        };
        this.eraseTrack = (trackId, peerId) => {
            this.trackIdToTrack.delete(trackId);
            const midToTrackId = Array.from(this.midToTrackId.entries());
            const [mid, _trackId] = midToTrackId.find(([mid, mapTrackId]) => mapTrackId === trackId);
            this.midToTrackId.delete(mid);
            this.idToPeer.get(peerId).trackIdToMetadata.delete(trackId);
            this.disabledTrackEncodings.delete(trackId);
        };
        this.getPeerId = () => this.localPeer.id;
        this.callbacks = config === null || config === void 0 ? void 0 : config.callbacks;
    }
    /**
     * Adds track that will be sent to the RTC Engine.
     * @param track - Audio or video track e.g. from your microphone or camera.
     * @param stream  - Stream that this track belongs to.
     * @param trackMetadata - Any information about this track that other peers will
     * receive in {@link Callbacks.onPeerJoined}. E.g. this can source of the track - wheather it's
     * screensharing, webcam or some other media device.
     * @param simulcastConfig - Simulcast configuration. By default simulcast is disabled.
     * For more information refer to {@link SimulcastConfig}.
     * @param maxBandwidth - maximal bandwidth this track can use.
     * Defaults to 0 which is unlimited.
     * This option has no effect for simulcast and audio tracks.
     * For simulcast tracks use `{@link MembraneWebRTC.setTrackBandwidth}.
     * @returns {string} Returns id of added track
     * @example
     * ```ts
     * let localStream: MediaStream = new MediaStream();
     * try {
     *   localAudioStream = await navigator.mediaDevices.getUserMedia(
     *     AUDIO_CONSTRAINTS
     *   );
     *   localAudioStream
     *     .getTracks()
     *     .forEach((track) => localStream.addTrack(track));
     * } catch (error) {
     *   console.error("Couldn't get microphone permission:", error);
     * }
     *
     * try {
     *   localVideoStream = await navigator.mediaDevices.getUserMedia(
     *     VIDEO_CONSTRAINTS
     *   );
     *   localVideoStream
     *     .getTracks()
     *     .forEach((track) => localStream.addTrack(track));
     * } catch (error) {
     *  console.error("Couldn't get camera permission:", error);
     * }
     *
     * localStream
     *  .getTracks()
     *  .forEach((track) => webrtc.addTrack(track, localStream));
     * ```
     */
    addTrack(track, stream, trackMetadata = new Map(), simulcastConfig = { enabled: false, active_encodings: [] }, maxBandwidth = 0 // unlimited bandwidth
    ) {
        if (!simulcastConfig.enabled && !(typeof maxBandwidth === "number"))
            throw "Invalid type of `maxBandwidth` argument for a non-simulcast track, expected: number";
        if (this.getPeerId() === "")
            throw "Cannot add tracks before being accepted by the server";
        const trackId = this.getTrackId((0, uuid_1.v4)());
        this.localTracksWithStreams.push({ track, stream });
        this.localPeer.trackIdToMetadata.set(trackId, trackMetadata);
        const trackContext = new TrackContextImpl(this.localPeer, trackId, trackMetadata);
        trackContext.track = track;
        trackContext.stream = stream;
        trackContext.simulcastConfig = simulcastConfig;
        trackContext.maxBandwidth = maxBandwidth;
        this.localTrackIdToTrack.set(trackId, trackContext);
        if (this.connection) {
            this.addTrackToConnection(trackContext);
            this.connection
                .getTransceivers()
                .forEach((transceiver) => (transceiver.direction =
                transceiver.direction === "sendrecv"
                    ? "sendonly"
                    : transceiver.direction));
        }
        let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({ type: "renegotiateTracks" });
        this.sendMediaEvent(mediaEvent);
        return trackId;
    }
    createTransceiverConfig(trackContext) {
        let transceiverConfig;
        if (trackContext.track.kind === "audio") {
            transceiverConfig = this.createAudioTransceiverConfig(trackContext);
        }
        else {
            transceiverConfig = this.createVideoTransceiverConfig(trackContext);
        }
        return transceiverConfig;
    }
    createAudioTransceiverConfig(_trackContext) {
        return { direction: "sendonly" };
    }
    createVideoTransceiverConfig(trackContext) {
        var _a;
        let transceiverConfig;
        if (trackContext.simulcastConfig.enabled) {
            transceiverConfig = const_1.simulcastTransceiverConfig;
            const trackActiveEncodings = trackContext.simulcastConfig.active_encodings;
            let disabledTrackEncodings = [];
            (_a = transceiverConfig.sendEncodings) === null || _a === void 0 ? void 0 : _a.forEach((encoding) => {
                if (trackActiveEncodings.includes(encoding.rid)) {
                    encoding.active = true;
                }
                else {
                    disabledTrackEncodings.push(encoding.rid);
                }
            });
            this.disabledTrackEncodings.set(trackContext.trackId, disabledTrackEncodings);
        }
        else {
            transceiverConfig = {
                direction: "sendonly",
                sendEncodings: [
                    {
                        active: true,
                    },
                ],
            };
        }
        if (trackContext.maxBandwidth && transceiverConfig.sendEncodings)
            this.applyBandwidthLimitation(transceiverConfig.sendEncodings, trackContext.maxBandwidth);
        return transceiverConfig;
    }
    applyBandwidthLimitation(encodings, max_bandwidth) {
        if (typeof max_bandwidth === "number") {
            // non-simulcast limitation
            this.splitBandwidth(encodings, max_bandwidth * 1024);
        }
        else {
            // simulcast bandwidth limit
            encodings
                .filter((encoding) => encoding.rid)
                .forEach((encoding) => {
                const limit = max_bandwidth.get(encoding.rid) || 0;
                if (limit > 0) {
                    encoding.maxBitrate = limit * 1024;
                }
                else
                    delete encoding.maxBitrate;
            });
        }
    }
    splitBandwidth(encodings, bandwidth) {
        if (bandwidth === 0) {
            encodings.forEach((encoding) => delete encoding.maxBitrate);
            return;
        }
        if (encodings.length == 0) {
            // This most likely is a race condition. Log an error and prevent catastrophic failure
            console.error("Attempted to limit bandwidth of the track that doesn't have any encodings");
            return;
        }
        // We are solving the following equation:
        // x + (k0/k1)^2 * x + (k0/k2)^2 * x + ... + (k0/kn)^2 * x = bandwidth
        // where x is the bitrate for the first encoding, kn are scaleResolutionDownBy factors
        // square is dictated by the fact that k0/kn is a scale factor, but we are interested in the total number of pixels in the image
        const firstScaleDownBy = encodings[0].scaleResolutionDownBy || 1;
        const bitrate_parts = encodings.reduce((acc, value) => acc + (firstScaleDownBy / (value.scaleResolutionDownBy || 1)) ** 2, 0);
        const x = bandwidth / bitrate_parts;
        encodings.forEach((value) => {
            value.maxBitrate =
                x * (firstScaleDownBy / (value.scaleResolutionDownBy || 1)) ** 2;
        });
    }
    /**
     * Replaces a track that is being sent to the RTC Engine.
     * @param track - Audio or video track.
     * @param {string} trackId - Id of audio or video track to replace.
     * @param {MediaStreamTrack} newTrack
     * @param {any} [newMetadata] - Optional track metadata to apply to the new track. If no
     *                              track metadata is passed, the old track metadata is retained.
     * @returns {Promise<boolean>} success
     * @example
     * ```ts
     * // setup camera
     * let localStream: MediaStream = new MediaStream();
     * try {
     *   localVideoStream = await navigator.mediaDevices.getUserMedia(
     *     VIDEO_CONSTRAINTS
     *   );
     *   localVideoStream
     *     .getTracks()
     *     .forEach((track) => localStream.addTrack(track));
     * } catch (error) {
     *   console.error("Couldn't get camera permission:", error);
     * }
     * let oldTrackId;
     * localStream
     *  .getTracks()
     *  .forEach((track) => trackId = webrtc.addTrack(track, localStream));
     *
     * // change camera
     * const oldTrack = localStream.getVideoTracks()[0];
     * let videoDeviceId = "abcd-1234";
     * navigator.mediaDevices.getUserMedia({
     *      video: {
     *        ...(VIDEO_CONSTRAINTS as {}),
     *        deviceId: {
     *          exact: videoDeviceId,
     *        },
     *      }
     *   })
     *   .then((stream) => {
     *     let videoTrack = stream.getVideoTracks()[0];
     *     webrtc.replaceTrack(oldTrackId, videoTrack);
     *   })
     *   .catch((error) => {
     *     console.error('Error switching camera', error);
     *   })
     * ```
     */
    async replaceTrack(trackId, newTrack, newTrackMetadata) {
        const trackContext = this.localTrackIdToTrack.get(trackId);
        const sender = this.findSender(trackContext.track.id);
        if (sender) {
            return sender
                .replaceTrack(newTrack)
                .then(() => {
                const trackMetadata = newTrackMetadata || this.localTrackIdToTrack.get(trackId).metadata;
                trackContext.track = newTrack;
                this.updateTrackMetadata(trackId, trackMetadata);
                return true;
            })
                .catch(() => false);
        }
        return false;
    }
    /**
     * Updates maximum bandwidth for the track identified by trackId.
     * This value directly translates to quality of the stream and, in case of video, to the amount of RTP packets being sent.
     * In case trackId points at the simulcast track bandwidth is split between all of the variant streams proportionally to their resolution.
     *
     * @param {string} trackId
     * @param {BandwidthLimit} bandwidth in kbps
     * @returns {Promise<boolean>} success
     */
    setTrackBandwidth(trackId, bandwidth) {
        // FIXME: maxBandwidth in TrackContext is not updated
        const trackContext = this.localTrackIdToTrack.get(trackId);
        if (!trackContext) {
            return Promise.reject(`Track '${trackId}' doesn't exist`);
        }
        const sender = this.findSender(trackContext.track.id);
        const parameters = sender.getParameters();
        if (parameters.encodings.length === 0) {
            parameters.encodings = [{}];
        }
        else {
            this.applyBandwidthLimitation(parameters.encodings, bandwidth);
        }
        return sender
            .setParameters(parameters)
            .then(() => {
            let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
                type: "trackVariantBitrates",
                data: {
                    trackId: trackId,
                    variantBitrates: this.getTrackBitrates(trackId),
                },
            });
            this.sendMediaEvent(mediaEvent);
            return true;
        })
            .catch((_error) => false);
    }
    /**
     * Updates maximum bandwidth for the given simulcast encoding of the given track.
     *
     * @param {string} trackId - id of the track
     * @param {string} rid - rid of the encoding
     * @param {BandwidthLimit} bandwidth - desired max bandwidth used by the encoding (in kbps)
     * @returns
     */
    setEncodingBandwidth(trackId, rid, bandwidth) {
        const trackContext = this.localTrackIdToTrack.get(trackId);
        if (!trackContext) {
            return Promise.reject(`Track '${trackId}' doesn't exist`);
        }
        const sender = this.findSender(trackContext.track.id);
        const parameters = sender.getParameters();
        const encoding = parameters.encodings.find((encoding) => encoding.rid === rid);
        if (!encoding) {
            return Promise.reject(`Encoding with rid '${rid}' doesn't exist`);
        }
        else if (bandwidth === 0) {
            delete encoding.maxBitrate;
        }
        else {
            encoding.maxBitrate = bandwidth * 1024;
        }
        return sender
            .setParameters(parameters)
            .then(() => {
            let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
                type: "trackVariantBitrates",
                data: {
                    trackId: trackId,
                    variantBitrates: this.getTrackBitrates(trackId),
                },
            });
            this.sendMediaEvent(mediaEvent);
            return true;
        })
            .catch((_error) => false);
    }
    /**
     * Removes a track from connection that was being sent to the RTC Engine.
     * @param {string} trackId - Id of audio or video track to remove.
     * @example
     * ```ts
     * // setup camera
     * let localStream: MediaStream = new MediaStream();
     * try {
     *   localVideoStream = await navigator.mediaDevices.getUserMedia(
     *     VIDEO_CONSTRAINTS
     *   );
     *   localVideoStream
     *     .getTracks()
     *     .forEach((track) => localStream.addTrack(track));
     * } catch (error) {
     *   console.error("Couldn't get camera permission:", error);
     * }
     *
     * let trackId
     * localStream
     *  .getTracks()
     *  .forEach((track) => trackId = webrtc.addTrack(track, localStream));
     *
     * // remove track
     * webrtc.removeTrack(trackId)
     * ```
     */
    removeTrack(trackId) {
        const trackContext = this.localTrackIdToTrack.get(trackId);
        const sender = this.findSender(trackContext.track.id);
        this.connection.removeTrack(sender);
        let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({ type: "renegotiateTracks" });
        this.sendMediaEvent(mediaEvent);
        this.localTrackIdToTrack.delete(trackId);
        this.localPeer.trackIdToMetadata.delete(trackId);
    }
    /**
     * Currently, this function only works when DisplayManager in RTC Engine is
     * enabled and simulcast is disabled.
     *
     * Prioritizes a track in connection to be always sent to browser.
     *
     * @param {string} trackId - Id of video track to prioritize.
     */
    prioritizeTrack(trackId) {
        let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
            type: "prioritizeTrack",
            data: { trackId },
        });
        this.sendMediaEvent(mediaEvent);
    }
    /**
     * Currently, this function only works when DisplayManager in RTC Engine is
     * enabled and simulcast is disabled.
     *
     * Unprioritizes a track.
     *
     * @param {string} trackId - Id of video track to unprioritize.
     */
    unprioritizeTrack(trackId) {
        let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
            type: "unprioritizeTrack",
            data: { trackId },
        });
        this.sendMediaEvent(mediaEvent);
    }
    /**
     * Currently this function has no effect.
     *
     * This function allows to adjust resolution and number of video tracks sent by an SFU to a client.
     *
     * @param {number} bigScreens - number of screens with big size
     * (if simulcast is used this will limit number of tracks sent with highest quality).
     * @param {number} smallScreens - number of screens with small size
     * (if simulcast is used this will limit number of tracks sent with lowest quality).
     * @param {number} mediumScreens - number of screens with medium size
     * (if simulcast is used this will limit number of tracks sent with medium quality).
     * @param {boolean} allSameSize - flag that indicates whether all screens should use the same quality
     */
    setPreferedVideoSizes(bigScreens, smallScreens, mediumScreens = 0, allSameSize = false) {
        let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
            type: "preferedVideoSizes",
            data: { bigScreens, mediumScreens, smallScreens, allSameSize },
        });
        this.sendMediaEvent(mediaEvent);
    }
    /**
     * Sets track encoding that server should send to the client library.
     *
     * The encoding will be sent whenever it is available.
     * If choosen encoding is temporarily unavailable, some other encoding
     * will be sent until choosen encoding becomes active again.
     *
     * @param {string} trackId - id of track
     * @param {TrackEncoding} encoding - encoding to receive
     * @example
     * ```ts
     * webrtc.setTargetTrackEncoding(incomingTrackCtx.trackId, "l")
     * ```
     */
    setTargetTrackEncoding(trackId, encoding) {
        let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
            type: "setTargetTrackVariant",
            data: {
                trackId: trackId,
                variant: encoding,
            },
        });
        this.sendMediaEvent(mediaEvent);
    }
    /**
     * Enables track encoding so that it will be sent to the server.
     * @param {string} trackId - id of track
     * @param {TrackEncoding} encoding - encoding that will be enabled
     * @example
     * ```ts
     * const trackId = webrtc.addTrack(track, stream, {}, {enabled: true, active_encodings: ["l", "m", "h"]});
     * webrtc.disableTrackEncoding(trackId, "l");
     * // wait some time
     * webrtc.enableTrackEncoding(trackId, "l");
     * ```
     */
    enableTrackEncoding(trackId, encoding) {
        var _a, _b, _c;
        let track = (_a = this.localTrackIdToTrack.get(trackId)) === null || _a === void 0 ? void 0 : _a.track;
        let newDisabledTrackEncodings = (_b = this.disabledTrackEncodings
            .get(trackId)) === null || _b === void 0 ? void 0 : _b.filter((en) => en !== encoding);
        this.disabledTrackEncodings.set(trackId, newDisabledTrackEncodings);
        let sender = (_c = this.connection) === null || _c === void 0 ? void 0 : _c.getSenders().filter((sender) => sender.track === track)[0];
        let params = sender === null || sender === void 0 ? void 0 : sender.getParameters();
        params.encodings.filter((en) => en.rid == encoding)[0].active = true;
        sender === null || sender === void 0 ? void 0 : sender.setParameters(params);
    }
    /**
     * Disables track encoding so that it will be no longer sent to the server.
     * @param {string} trackId - id of track
     * @param {rackEncoding} encoding - encoding that will be disabled
     * @example
     * ```ts
     * const trackId = webrtc.addTrack(track, stream, {}, {enabled: true, active_encodings: ["l", "m", "h"]});
     * webrtc.disableTrackEncoding(trackId, "l");
     * ```
     */
    disableTrackEncoding(trackId, encoding) {
        var _a, _b;
        let track = (_a = this.localTrackIdToTrack.get(trackId)) === null || _a === void 0 ? void 0 : _a.track;
        this.disabledTrackEncodings.get(trackId).push(encoding);
        let sender = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.getSenders().filter((sender) => sender.track === track)[0];
        let params = sender === null || sender === void 0 ? void 0 : sender.getParameters();
        params.encodings.filter((en) => en.rid == encoding)[0].active = false;
        sender === null || sender === void 0 ? void 0 : sender.setParameters(params);
    }
    findSender(trackId) {
        return this.connection.getSenders().find((sender) => sender.track && sender.track.id === trackId);
    }
    getTrackId(uuid) {
        return `${this.getPeerId()}:${uuid}`;
    }
    async createAndSendOffer() {
        if (!this.connection)
            return;
        try {
            const offer = await this.connection.createOffer();
            await this.connection.setLocalDescription(offer);
            let mediaEvent = (0, mediaEvent_1.generateCustomEvent)({
                type: "sdpOffer",
                data: {
                    sdpOffer: offer,
                    trackIdToTrackMetadata: this.getTrackIdToMetadata(),
                    trackIdToTrackBitrates: this.getTrackIdToTrackBitrates(),
                    midToTrackId: this.getMidToTrackId(),
                },
            });
            this.sendMediaEvent(mediaEvent);
            for (let track of this.localTrackIdToTrack.values()) {
                track.negotiationStatus = "offered";
            }
        }
        catch (error) {
            console.error(error);
        }
    }
}
exports.MembraneWebRTC = MembraneWebRTC;
