import type TypedEmitter from 'typed-emitter';
import type { SerializedMediaEvent } from './mediaEvent';
import type { MediaEvent_Track_SimulcastConfig } from '@fishjam-cloud/protobufs/server';
import { Variant } from '@fishjam-cloud/protobufs/shared';

export type LocalTrackId = string;
export type MLineId = string;
export type MediaStreamTrackId = string;
export type RemoteTrackId = string;
export type MetadataJson = string;

export type TrackKind = 'audio' | 'video';

/**
 * Type describing Voice Activity Detection statuses.
 *
 * - `speech` - voice activity has been detected
 * - `silence` - lack of voice activity has been detected
 */
export type VadStatus = 'speech' | 'silence';

/**
 * Type describing maximal bandwidth that can be used, in kbps. 0 is interpreted as unlimited bandwidth.
 */
export type BandwidthLimit = number;

/**
 * Type describing bandwidth limit for simulcast track.
 * It is a mapping (encoding => BandwidthLimit).
 * If encoding isn't present in this mapping, it will be assumed that this particular encoding shouldn't have any bandwidth limit
 */
export type SimulcastBandwidthLimit = Map<Variant, BandwidthLimit>;

/**
 * Type describing bandwidth limitation of a Track, including simulcast and non-simulcast tracks.
 * A sum type of `BandwidthLimit` and `SimulcastBandwidthLimit`
 */
export type TrackBandwidthLimit = BandwidthLimit | SimulcastBandwidthLimit;

/**
 * Type describing possible reasons for currently selected encoding.
 * - `other` - the exact reason couldn't be determined
 * - `encodingInactive` - previously selected encoding became inactive
 * - `lowBandwidth` - there is no longer enough bandwidth to maintain previously selected encoding
 */
export type EncodingReason = 'other' | 'encodingInactive' | 'lowBandwidth';

/**
 * Track's context i.e. all data that can be useful when operating on track.
 */
interface TrackContextFields {
  readonly track: MediaStreamTrack | null;

  /**
   * Stream this track belongs to.
   */
  readonly stream: MediaStream | null;

  /**
   * Endpoint this track comes from.
   */
  readonly endpoint: Endpoint;

  /**
   * Track id. It is generated by RTC engine and takes form `endpoint_id:<random_uuidv4>`.
   * It is WebRTC agnostic i.e. it does not contain `mid` or `stream id`.
   */

  readonly trackId: string;
  /**
   * Simulcast configuration.
   * Only present for local tracks.
   */
  readonly simulcastConfig?: MediaEvent_Track_SimulcastConfig;

  /**
   * Any info that was passed in {@link WebRTCEndpoint.addTrack}.
   */
  readonly metadata?: unknown;

  readonly maxBandwidth?: TrackBandwidthLimit;

  readonly vadStatus: VadStatus;

  /**
   * Encoding that is currently received.
   * Only present for remote tracks.
   */
  readonly encoding?: Variant;

  /**
   * The reason of currently selected encoding.
   * Only present for remote tracks.
   */
  readonly encodingReason?: EncodingReason;
}

export interface TrackContextEvents {
  /**
   * Emitted each time track encoding has changed.
   *
   * Track encoding can change in the following cases:
   * - when user requested a change
   * - when sender stopped sending some encoding (because of bandwidth change)
   * - when receiver doesn't have enough bandwidth
   *
   * Some of those reasons are indicated in {@link TrackContext.encodingReason}.
   */
  encodingChanged: (context: TrackContext) => void;

  /**
   * Emitted every time an update about voice activity is received from the server.
   */
  voiceActivityChanged: (context: TrackContext) => void;
}

export interface TrackContext extends TrackContextFields, TypedEmitter<Required<TrackContextEvents>> {}

export type TrackNegotiationStatus = 'awaiting' | 'offered' | 'done';

/**
 * Events emitted by the {@link WebRTCEndpoint} instance.
 */
export interface WebRTCEndpointEvents {
  /**
   * Emitted each time WebRTCEndpoint need to send some data to the server.
   */
  sendMediaEvent: (mediaEvent: SerializedMediaEvent) => void;

  /**
   * Emitted when endpoint of this {@link WebRTCEndpoint} instance is ready. Triggered by {@link WebRTCEndpoint.connect}
   */
  connected: (endpointId: string, otherEndpoints: Endpoint[]) => void;

  /**
   * Emitted when endpoint of this {@link WebRTCEndpoint} instance was removed.
   */
  disconnected: () => void;

  /**
   * Emitted when data in a new track arrives.
   *
   * This event is always emitted after {@link trackAdded}.
   * It informs the user that data related to the given track arrives and can be played or displayed.
   */
  trackReady: (ctx: TrackContext) => void;

  /**
   * Emitted each time the endpoint which was already in the room, adds new track. Fields track and stream will be set to null.
   * These fields will be set to non-null value in {@link trackReady}
   */
  trackAdded: (ctx: TrackContext) => void;

  /**
   * Emitted when some track will no longer be sent.
   *
   * It will also be emitted before {@link endpointRemoved} for each track of this endpoint.
   */
  trackRemoved: (ctx: TrackContext) => void;

  /**
   * Emitted each time endpoint has its track metadata updated.
   */
  trackUpdated: (ctx: TrackContext) => void;

  /**
   * Emitted each time new endpoint is added to the room.
   */
  endpointAdded: (endpoint: Endpoint) => void;

  /**
   * Emitted each time endpoint is removed, emitted only for other endpoints.
   */
  endpointRemoved: (endpoint: Endpoint) => void;

  /**
   * Emitted each time endpoint has its metadata updated.
   */
  endpointUpdated: (endpoint: Endpoint) => void;

  /**
   * Emitted in case of errors related to multimedia session e.g. ICE connection.
   */
  connectionError: (error: { message: string; event: Event }) => void;

  /**
   * Emitted in case of errors related to multimedia session e.g. ICE connection.
   */
  signalingError: (error: { message: string }) => void;

  /**
   * Currently, this event is only emitted when DisplayManager in RTC Engine is
   * enabled and simulcast is disabled.
   *
   * Emitted when priority of video tracks have changed.
   * @param enabledTracks - list of tracks which will be sent to client from SFU
   * @param disabledTracks - list of tracks which will not be sent to client from SFU
   */
  tracksPriorityChanged: (enabledTracks: TrackContext[], disabledTracks: TrackContext[]) => void;

  /**
   * Emitted every time the server estimates client's bandwidth.
   *
   * @param {bigint} estimation - client's available incoming bitrate estimated
   * by the server. It's measured in bits per second.
   */
  bandwidthEstimationChanged: (estimation: bigint) => void;

  /**
   * Emitted each time track encoding has been disabled.
   */
  trackEncodingDisabled: (context: TrackContext, encoding: Variant) => void;

  /**
   * Emitted each time track encoding has been enabled.
   */
  trackEncodingEnabled: (context: TrackContext, encoding: Variant) => void;

  targetTrackEncodingRequested: (event: { trackId: string; variant: Variant }) => void;

  disconnectRequested: (event: any) => void;

  localTrackAdded: (event: {
    trackId: string;
    track: MediaStreamTrack;
    stream: MediaStream;
    trackMetadata?: unknown;
    simulcastConfig: MediaEvent_Track_SimulcastConfig;
    maxBandwidth: TrackBandwidthLimit;
  }) => void;

  localTrackRemoved: (event: { trackId: string }) => void;

  localTrackReplaced: (event: { trackId: string; track: MediaStreamTrack | null }) => void;

  localTrackMuted: (event: { trackId: string }) => void;

  localTrackUnmuted: (event: { trackId: string }) => void;

  localTrackBandwidthSet: (event: { trackId: string; bandwidth: BandwidthLimit }) => void;

  localTrackEncodingBandwidthSet: (event: { trackId: string; rid: Variant; bandwidth: BandwidthLimit }) => void;

  localTrackEncodingEnabled: (event: { trackId: string; encoding: Variant }) => void;

  localTrackEncodingDisabled: (event: { trackId: string; encoding: Variant }) => void;

  localEndpointMetadataChanged: (event: { metadata: unknown }) => void;

  localTrackMetadataChanged: (event: { trackId: string; metadata: unknown }) => void;
}

/**
 * Interface describing Endpoint.
 */
export interface Endpoint {
  /**
   * Endpoint's id. It is assigned by user in custom logic that use backend API.
   */
  id: string;
  /**
   * Type of the endpoint, e.g. "webrtc", "hls" or "rtsp".
   */
  type: string;
  /**
   * Any information that was provided in {@link WebRTCEndpoint.connect}.
   */
  metadata?: unknown;
  /**
   * List of tracks that are sent by the endpoint.
   */
  tracks: Map<string, TrackContext>;
}
